{"searchDocs":[{"title":"Information and Roadmap","type":0,"sectionRef":"#","url":"/info","content":"","keywords":"future maintenance license support feedback gonzalo m√ºller bravo gonzalo muller bravo","version":"Next"},{"title":"Licenses‚Äã","type":1,"pageTitle":"Information and Roadmap","url":"/info#licenses","content":" jko executable can be used in personal or commercial projects for free. This documentation content is licensed under CC BY-SA 4.0.  jko Executable and Source code Executable Software License (ESL) Copyright (c) 2025 Gonzalo M√ºller Bravo Permission is hereby granted, free of charge, to any person obtaining a copy of this executable software (the &quot;Software&quot;) for use, testing, evaluation, and distribution‚Äîincluding for commercial purposes‚Äîsubject to the following terms and conditions: Executable-Only Distribution:The Software is provided solely in executable (binary) form. The corresponding source code is not provided under this license. Modification and Derivative Works:Users are not permitted to modify, reverse-engineer, decompile, or create derivative works of the Software in any form. The Software must be used exactly as distributed. Redistribution:Redistribution of the original executable must include a copy of this license in its entirety and must retain all copyright and licensing notices contained herein. Any redistribution must clearly state that it is the original unmodified version of the Software. Attribution:The name(s) of the original author(s) shall not be used to endorse or promote any redistributed version of the Software without prior written permission from the author(s). Future Licensing Changes:This license covers only the distribution of the Software in its current executable form. The author reserves the right to change the licensing terms in future releases, including the option to publish the source code under a different license. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  jko Documentation (this documentation) Creative Commons Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0) Copyright (c) 2025 Gonzalo M√ºller Bravo You are free to share and adapt it, provided you give appropriate credit and distribute any derivative works under the same license.    ","version":"Next","tagName":"h2"},{"title":"üîß Maintenance Plan‚Äã","type":1,"pageTitle":"Information and Roadmap","url":"/info#-maintenance-plan","content":" I am committed to the continued growth and evolution of this project. Currently, this project is distributed as an executable under a custom license that restricts modifications and reverse-engineering. However, I recognize the value of open collaboration and the benefits of a more permissive licensing model.  Maintenance and Bug Fixes:Right now, my main focus is on keeping the executable stable and addressing any bugs that arise, along with continuously updating and improving the documentation so that everyone has a clear understanding of how to use the project. I‚Äôm holding off on rolling out major new features or enhancements until the project transitions to an open-source model‚Äîwhere I look forward to welcoming contributions and fresh ideas from the community.  Looking Ahead:With the support I receive‚Äîwhether through donations, sponsorships, or community contributions‚ÄîI plan to transition to a more permissive license, such as the MIT License or GNU General Public License, and release the source code. This support primarily covers the initial effort and time I invested in bringing this wonderful project to life. This change will allow free and open modification of the software and make it easier for anyone to contribute ideas, improvements, and innovations.  I remain dedicated to transparency and will keep you updated as my plans evolve. The timing and specifics of this transition may change depending on future legal, financial, and developmental considerations.    ","version":"Next","tagName":"h2"},{"title":"ü§ù Support‚Äã","type":1,"pageTitle":"Information and Roadmap","url":"/info#-support","content":" Your donations, sponsorships, and community contributions help keep this project running and evolving, while also supporting a transition to a more permissive license. I welcome both one-time donations or recurring sponsorships.   Donate   Donate    ","version":"Next","tagName":"h2"},{"title":"üìù Feedback‚Äã","type":1,"pageTitle":"Information and Roadmap","url":"/info#-feedback","content":" Your feedback is invaluable. It helps me identify gaps and areas that need simplification. I continuously refine the documentation to ensure it remains effective and user-friendly, and the executable benefits from ongoing, community-driven improvements.  jko Executable Feedback Submit  jko Documentation Feedback Submit  Bugs Report jko executables issues Report jko documentation issues ","version":"Next","tagName":"h2"},{"title":"Summary","type":0,"sectionRef":"#","url":"/summary","content":"","keywords":"","version":"Next"},{"title":"‚≠ê Key Features‚Äã","type":1,"pageTitle":"Summary","url":"/summary#-key-features","content":" Run Scripts: Execute predefined commands sequentially‚Äîideal for automating workflows such as builds, tests, and deployments. Function Scripts: Leverage reusable logic for dynamic execution, allowing customization based on parameters and context. Declarative Syntax: Use special keywords‚Äî$pre, $post, $catch, $comment, $disable‚Äîto define script behavior, ensuring predictable execution and unlocking additional functionality. Script Lifecycle Management: $pre and $post directives manage actions before and after script execution.$catch handles errors gracefully. Grouping Scripts: The | operator lets multiple scripts share a common definition, reducing duplication and streamlining execution. Organize Scripts and Dependencies: Use a JavaScript file (e.g., jko.js) to manage scripts and/or dependencies.Alternatively, use a JSON file with $extends and $installs directives. Environment Variables Handling: jko-generated variables use the jko_ prefix.Compatibility variables prefixed with npm_package_ are also supported. Easy and Quick Settings: Configure via jko.js fields like envFile, logLevel, and packageManager.Or use command-line options such as --config-file, --env-file, --log, and --package-manager. Well Documented: Comprehensive documentation is provided.Quick information is available via the --help command-line option.  ","version":"Next","tagName":"h2"},{"title":"üëç Advantages‚Äã","type":1,"pageTitle":"Summary","url":"/summary#-advantages","content":" Predictability: Clearly defined execution flows ensure consistent and reliable outcomes. Modularity: Easily extend and modify scripts and dependencies across various environments. Automation-Friendly: Simplifies complex scripting tasks, reducing manual efforts and potential errors. Clear Output: Informative, colored labels help you quickly understand what happened during execution. ","version":"Next","tagName":"h2"},{"title":"CLI Options","type":0,"sectionRef":"#","url":"/usage/cli","content":"","keywords":"cli options options vs argument --config-file --env-file --log --package-manager","version":"Next"},{"title":"--config-file‚Äã","type":1,"pageTitle":"CLI Options","url":"/usage/cli#--config-file","content":" --config-file allows the user to specify a custom configuration file for jko, overriding the default settings defined in jko.js (or package.json).  --config-file can specified any .js, .mjs, .cjs or .json file. The file path must start with /, ./, or `.  $¬†jko¬†-c=./path/to/config.js¬†...¬†  --config-file can specified a package. The package must be available, i.e. it must be installed first.  $¬†jko¬†--config-file=somePackageName¬†...¬†  note --config-file is the only option available exclusively via the CLI; all other options can be set in configuration files (for example, in jko.js, package.json, or even the file specified using --config-file), e.g. the --env-file option can be defined using the envFile field.    ","version":"Next","tagName":"h2"},{"title":"Options vs Arguments‚Äã","type":1,"pageTitle":"CLI Options","url":"/usage/cli#options-vs-arguments","content":" Options are values that you pass to the jko.Arguments are values passed to your script.    Options are defined after jko.Arguments are defined after your script.    ‚¨áÔ∏è  $¬†jko¬†--option1=value1¬†...¬†--option5=value5¬†yourScript¬†arg1¬†...¬†argN¬†  Options are used internally by jko.Arguments are used internally by your script.   ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/usage/declarative/intro","content":"","keywords":"","version":"Next"},{"title":"Using Directives‚Äã","type":1,"pageTitle":"Introduction","url":"/usage/declarative/intro#using-directives","content":" These directives are meant to be used as keys within the scripts object, defining the required behaviors:  export default { scripts: { &quot;directive ...&quot;: &quot;...&quot; } }   jko recognizes these structures and interprets them to execute the appropriate operations.  This implies that some directives cannot be used as script names.  The structure follows this format:   &quot;$directiveName (scriptName)&quot;: &quot;value&quot;   The $ appears first.Then directive name.It is followed by one space.The script name affected by the directive is enclosed in parentheses.  e.g.   &quot;$comment (scriptName)&quot;: &quot;value&quot;  ","version":"Next","tagName":"h2"},{"title":"JSON-only directives","type":0,"sectionRef":"#","url":"/usage/declarative/json","content":"","keywords":"json $extends $installs","version":"Next"},{"title":"$extends‚Äã","type":1,"pageTitle":"JSON-only directives","url":"/usage/declarative/json#extends","content":" To extend scripts in JSON, use the $extends directive, which allows you to inherit scripts from an external source.  { &quot;scripts&quot;: { &quot;$extends&quot;: &quot;./path/to/script.js&quot; } }   The external file contains predefined scripts that will be incorporated into the current configuration.This ensures reusability and modular script management across multiple configurations.  info File can be any .js, .mjs, .cjs or .json file.  warning The file path must start with /, ./, or ../.  To extend from a package:  { &quot;scripts&quot;: { &quot;$extends&quot;: &quot;somePackageName&quot; } }   warning The package must be available, i.e. it must be installed first.    ","version":"Next","tagName":"h2"},{"title":"$installs‚Äã","type":1,"pageTitle":"JSON-only directives","url":"/usage/declarative/json#installs","content":" To set dependencies from an external source, use the $installs directive within the scripts object. This directive allows you to specify the file or package that contains the dependency definitions.  { &quot;scripts&quot;: { &quot;$installs&quot; : &quot;./some/path/dependencies.js&quot;, } }   info File can be any .js, .mjs, .cjs or .json file.  warning The file path must start with /, ./, or ../.  To use a package:  { &quot;scripts&quot;: { &quot;$installs&quot; : &quot;somePackageName&quot;, } }   warning The package must be available, i.e. it must be installed first.  warning For the specified $installs, only dependencies and devDependencies are parsed for installation; the packageManager setting is ignored. If you require a package manager other than the default, please use alternative configuration methods. ","version":"Next","tagName":"h2"},{"title":"Lifecycle hooks","type":0,"sectionRef":"#","url":"/usage/declarative/lifecycle","content":"","keywords":"$pre $post $catch chaining scripts","version":"Next"},{"title":"$pre and $post‚Äã","type":1,"pageTitle":"Lifecycle hooks","url":"/usage/declarative/lifecycle#pre-and-post","content":" To set lifecycle hooks for a script, use the $pre and $post directives within the scripts object. These directives define actions that should run before and after a specific script executes, respectively.  $pre (scriptName): Runs before the specified script.$post (scriptName): Runs after the specified script.The script name is enclosed in parentheses, linking the directive to the target script.The command or operation follows the directive as a string or a function.  export default { scripts: { &quot;$pre (yourScript)&quot;: &quot;echo 'Preparing for ...'&quot;, &quot;yourScript&quot;: &quot;someCommand&quot;, &quot;$post (yourScript)&quot;: &quot;echo 'Done!'&quot; } }     ","version":"Next","tagName":"h2"},{"title":"$catch‚Äã","type":1,"pageTitle":"Lifecycle hooks","url":"/usage/declarative/lifecycle#catch","content":" To handle errors for a script, use the $catch directive within the scripts object. This allows you to define specific actions to take when a script encounters an error.  $catch (scriptName): Specifies the error-handling action for the given script.The script name appears within parentheses, linking the directive to the target script.The error response command or operation follows the directive as a string or a function.  export default { scripts: { &quot;runTask&quot;: &quot;someTasks&quot;, &quot;$catch (runTask)&quot;: &quot;echo 'An error occurred during execution!'&quot; } }   This ensures that any errors encountered during script execution trigger a predefined response.  ","version":"Next","tagName":"h2"},{"title":"Chaining‚Äã","type":1,"pageTitle":"Lifecycle hooks","url":"/usage/declarative/lifecycle#chaining","content":" $catch is particularly useful because, when chaining commands, it ensures that the process continues even if one element fails, if that behavior is desired.  Check the following example:  export default { scripts: { &quot;yourScript1&quot;: &quot;echo someText1&quot;, &quot;yourScript2&quot;: &quot;exit 10&quot;, &quot;yourScript3&quot;: &quot;echo someText3&quot;, &quot;chain&quot;: &quot;jko -l=w yourScript1 &amp;&amp; jko -l=w yourScript2 &amp;&amp; jko -l=w yourScript3&quot;, } }   yourScript2 will intentionally fail (for demonstration purposes), breaking the chain:  $ jko chain someText1 ‚ó§ jko end - yourScript2: &quot;exit 10&quot; Failed. ‚ó£ ‚ó§ jko end - chain: &quot;jko -l=w yourScript1 &amp;&amp; jko -l=w yourScript2 &amp;&amp; jko -l=w yourScript3&quot; Failed. ‚ó£  Now, let's add $catch:  export default { scripts: { &quot;yourScript1&quot;: &quot;echo someText1&quot;, &quot;yourScript2&quot;: &quot;exit 10&quot;, &quot;$catch (yourScript2)&quot;: &quot;echo Ok!&quot;, &quot;yourScript3&quot;: &quot;echo someText3&quot;, &quot;chain&quot;: &quot;jko -l=w yourScript1 &amp;&amp; jko -l=w yourScript2 &amp;&amp; jko -l=w yourScript3&quot;, } }   $ jko chain someText1 Ok! ‚ó§ jko warn - $catch (yourScript2) executed. ‚ó£ someText3 ‚ó§ jko end - Successful execution of chain. ‚ó£ ","version":"Next","tagName":"h3"},{"title":"Function Scripts","type":0,"sectionRef":"#","url":"/usage/functions/run-function-script","content":"","keywords":"function scripts","version":"Next"},{"title":"Run a Function Script‚Äã","type":1,"pageTitle":"Function Scripts","url":"/usage/functions/run-function-script#run-a-function-script","content":" Given the following jko.js:   export default { scripts: { functionScript: function () { // do something } } }   $¬†jko¬†functionScript¬†  functionScript will be executed.  tip When scripts are listed, no useful description is displayed beyond the default &quot;Function&quot; label. $ jko scripts: functionScript: Function Use the $comment directive to add a descriptive comment. e.g. export default { scripts: { functionScript: function (param1, paramN) { // do something } '$comment (functionScript)': 'This function script that ...' } } $ jko scripts: functionScript: Function This function script that ...    ","version":"Next","tagName":"h2"},{"title":"Run a Function Script with Arguments‚Äã","type":1,"pageTitle":"Function Scripts","url":"/usage/functions/run-function-script#run-a-function-script-with-arguments","content":" Given the following jko.js:   export default { scripts: { functionScript: function (param1, paramN) { // do something } } }   $¬†jko¬†functionScript¬†arg1¬†argN¬†  jko will run functionScript with arg1 and argN as arguments to the function; that is, param1 will receive the value of arg1 and paramN will receive the value of argN.  For example:   export default { scripts: { functionScript: function (param1, paramN) { const a = parseFloat(param1) const b = parseFloat(paramN) console.log(`${a} + ${b} = ${a + b}`) } } }   $ jko functionScript 1 2 $ 1 + 2 = 3   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript 1 2)  Additionally, jko will set an environment variable for every argument passed in the command line, each named jko_arg_# and accessible in the function code through process.env.jko_arg_#.  For example:   export default { scripts: { functionScript: function () { const a = parseFloat(process.env.jko_arg_0) const b = parseFloat(process.env.jko_arg_1) console.log(`${a} + ${b} = ${a + b}`) } } }   $ jko functionScript 1 2 $ 1 + 2 = 3   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript 1 2)  info jko will create an environment variable for each argument passed in the command line, named jko_arg_#, where # starts at 0. For example, jko_arg_0 will contain the value of the first argument, and jko_arg_N_1 will contain the value of the last argument. arg1 saved in jko_arg_0 arg2 saved in jko_arg_1 arg3 saved in jko_arg_2 ...and so on.   ","version":"Next","tagName":"h2"},{"title":"Install dependencies","type":0,"sectionRef":"#","url":"/usage/install","content":"","keywords":"install dependencies devDependencies tree hierarchy package manager packageManager npm yarn","version":"Next"},{"title":"Install dependencies from a File‚Äã","type":1,"pageTitle":"Install dependencies","url":"/usage/install#install-dependencies-from-a-file","content":" $ jko install --config-file=./path/to/config.js   or  $ jko install -c=./path/to/config.js     ","version":"Next","tagName":"h2"},{"title":"Install dependencies from a Package‚Äã","type":1,"pageTitle":"Install dependencies","url":"/usage/install#install-dependencies-from-a-package","content":" $ jko install --config-file=somePackageName   or  $ jko install -c=somePackageName   The package must be available, i.e. It must be installed first.    ","version":"Next","tagName":"h2"},{"title":"Using a Specific Package Manager to Install Dependencies‚Äã","type":1,"pageTitle":"Install dependencies","url":"/usage/install#using-a-specific-package-manager-to-install-dependencies","content":" jko supports the following package managers:  npm (Default)pnpmyarn  $ jko install --package-manager=npm   or  $ jko install --p=npm   or by using the jko.js file (package.json or any other file specified with the --config-file option):  export default { dependencies: { packageName1: &quot;#.#.#&quot;, packageNameN: &quot;#.#.#&quot; }, devDependencies: { devPackageName1: &quot;#.#.#&quot;, devPackageNameN: &quot;#.#.#&quot; }, packageManager: 'npm', }   $ jko install     ","version":"Next","tagName":"h2"},{"title":"How Are Dependencies Installed‚Äã","type":1,"pageTitle":"Install dependencies","url":"/usage/install#how-are-dependencies-installed","content":" Before installation begins, $pre (install) is run if it exists.Dependencies are installed as follows:  Using a non-package.json file (e.g. jko.js):Each dependency is processed independently using the selected package manager command. For example: npm install some0@&quot;4.0.0&quot; &amp;&amp; npm install -D some1@&quot;5.0.0&quot; some2@&quot;6.0.0&quot;pnpm add some1@&quot;5.0.0&quot; some2@&quot;6.0.0&quot; Additionally, if a package.json file does not exist, it will be created; otherwise, it will be updated. Using package.json for installation:All dependencies are processed at once (e.g. by running npm install or yarn install).  If everything completes successfully, $post (install) is run if it exists. If an error occurs, $catch (install) is run if defined.  danger If an install task already exists, jko completely ignores it.   ","version":"Next","tagName":"h2"},{"title":"jko.js","type":0,"sectionRef":"#","url":"/usage/jkojs","content":"","keywords":"jko.js scripts dependencies devDependencies envFile logLevel packageManager package.json extending scripts","version":"Next"},{"title":"Extending Scripts with External Files‚Äã","type":1,"pageTitle":"jko.js","url":"/usage/jkojs#extending-scripts-with-external-files","content":" Leveraging the dynamic capabilities of JavaScript, jko.js files allow you to extend scripts and easily create dependency trees using external files‚Äîcapabilities that package.json cannot accommodate due to its static JSON structure.  Steps:  Create an External File:Define your additional scripts in a separate file and ensure that the file exports a default object containing a scripts field.  extra-scripts.js:  export default { scripts: { yourScript: &quot;someCommand&quot; } }   Reference the File in Your jko.js file:Import or require the external file in jko.js.  jko.js:  import extraScripts from './extra-scripts'   This step links the external definitions to your main script setup.  Merge the Script Definitions:Combine the scripts from the external file with your main set of scripts in the jko.js. You can do this manually or use a merging strategy (such as object spreading or a deep merge function) to consolidate all script definitions into one cohesive configuration.   project-folder/ ‚îú‚îÄ‚îÄ jko.js ‚îú‚îÄ‚îÄ extra-scripts.js ‚îî‚îÄ‚îÄ node_modules/somePackage/index.js   jko.js:   import extraScripts from './extra-scripts' import fromSomePackageScripts from 'somePackage' export default { scripts: { ...extraScripts.scripts, ...fromSomePackageScripts.scripts } }   Test and Validate:Run jko to ensure that the extended scripts integrate seamlessly and work as expected. Adjust any configurations as needed.  $ jko   A similar approach can be applied to dependencies. Check out the example below!  ","version":"Next","tagName":"h2"},{"title":"Create a Custom Tree of Dependencies‚Äã","type":1,"pageTitle":"jko.js","url":"/usage/jkojs#create-a-custom-tree-of-dependencies","content":"  project-folder/ ‚îú‚îÄ‚îÄ jko.js ‚îú‚îÄ‚îÄ dependencies.js ‚îú‚îÄ‚îÄ some/path/dependencies.js ‚îú‚îÄ‚îÄ another/path/dependencies.js ‚îî‚îÄ‚îÄ node_modules/package/dependencies.js   jko.js:  import { dependencies as dependencies1 } from './some/path/dependencies' import { devDependencies } from './another/path/dependencies' import { dependencies as dependencies2 } from 'package/dependencies' export default { dependencies: { ...dependencies1, ...dependencies2, }, devDependencies }  ","version":"Next","tagName":"h3"},{"title":"Managing Global Options","type":0,"sectionRef":"#","url":"/usage/options","content":"","keywords":"options environment log level envFile logLevel","version":"Next"},{"title":"How to set environment file‚Äã","type":1,"pageTitle":"Managing Global Options","url":"/usage/options#how-to-set-environment-file","content":" To set an environment, use the envFile field. This allows you to load external environment variables from a specified file.  export default { scripts: { yourScript1: &quot;someCommand&quot;, }, envFile: './path/to/.env', }   .env:  SOME_ENV_VAR=VALUE1   The environment variables can be reached in various contexts:  Function scripts: process.env.SOME_ENV_VARTraditional scripts: $SOME_ENV_VAROther processes: through mechanisms specific to each process (e.g., a Node.js process uses process.env.SOME_ENV_VAR)  ","version":"Next","tagName":"h2"},{"title":"How to set log level‚Äã","type":1,"pageTitle":"Managing Global Options","url":"/usage/options#how-to-set-log-level","content":" To set the log level, use the logLevel field. This allows you to define the verbosity of logging during execution.  logLevel specifies the desired log level:  &quot;info&quot; ‚Äì Shows general information and normal operations. Default.&quot;warn&quot; ‚Äì Displays warnings that don‚Äôt interrupt execution.&quot;error&quot; ‚Äì Logs only errors that need attention.  Setting the level to 'info' means that informational, warning, and error messages are all logged. In contrast, choosing 'warn' will filter out informational messages and log only warnings and errors, while selecting 'error' limits the logs to error messages alone. This hierarchical logging setup helps you control verbosity and focus on the severity of events as needed.  For example:  When using the 'error' log level and an error arises:  export default { scripts: { yourScript: &quot;exit 10&quot;, } // highlight-next-line, logLevel: 'error' }   $ jko yourScript ‚ó§ jko end - yourScript: &quot;exit 10&quot; Failed. ‚ó£  When using the 'warn' log level and an error arises:  export default { scripts: { yourScript: &quot;exit 10&quot;, } // highlight-next-line, logLevel: 'warn' }   $ jko yourScript ‚ó§ jko end - yourScript: &quot;exit 10&quot; Failed. ‚ó£  When using the 'info' log level and an error arises:  export default { scripts: { yourScript: &quot;exit 10&quot;, } // highlight-next-line, logLevel: 'info' }   $ jko yourScript ‚ó§ jko end - yourScript: &quot;exit 10&quot; Failed. ‚ó£  When using the 'error' log level and a warning arises:  export default { scripts: { yourScript: &quot;exit 10&quot;, &quot;$catch (yourScript)&quot;: &quot;echo Ok!&quot;, } // highlight-next-line, logLevel: 'error' }   $ jko yourScript Ok! ‚ó§ jko warn - $catch (yourScript) executed. ‚ó£ ‚ó§ jko end - Successful execution of yourScript. ‚ó£  When using the 'warn' log level and a warning arises:  export default { scripts: { yourScript: &quot;exit 10&quot;, &quot;$catch (yourScript)&quot;: &quot;echo Ok!&quot;, } // highlight-next-line, logLevel: 'warn' }   $ jko yourScript Ok! ‚ó§ jko warn - $catch (yourScript) executed. ‚ó£ ‚ó§ jko end - Successful execution of yourScript. ‚ó£  When using the 'info' log level and a warning arises:  export default { scripts: { yourScript: &quot;exit 10&quot;, &quot;$catch (yourScript)&quot;: &quot;echo Ok!&quot;, } // highlight-next-line, logLevel: 'info' }   $ jko yourScript Ok! ‚ó§ jko end - Successful execution of yourScript. ‚ó£  When any log level is applied and execution succeeds:  $ jko yourScript ... ‚ó§ jko end - Successful execution of yourScript. ‚ó£ ","version":"Next","tagName":"h2"},{"title":"Chaining Function Scripts","type":0,"sectionRef":"#","url":"/usage/functions/chaining-function-script","content":"","keywords":"chaining scripts chained scripts chaining function scripts chained function scripts","version":"Next"},{"title":"How is the return value handled‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#how-is-the-return-value-handled","content":" If the function returns a value and that value is not a string, nothing happens; the value is ignored.  However, if the return value is a string, jko will search for a script with that name and execute it.  Let's check following examples.  ","version":"Next","tagName":"h2"},{"title":"Example 1: A non‚Äëstring value is returned‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#example-1-a-nonstring-value-is-returned","content":"  export default { scripts: { functionScript: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) const result = a + b console.log(`${a} + ${b} = ${result}`) return result } } }   $ jko functionScript 1 2 $ 1 + 2 = 3   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript 1 2)  Nothing additional happens.  ","version":"Next","tagName":"h3"},{"title":"Example 2: A string value is returned‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#example-2-a-string-value-is-returned","content":"  export default { scripts: { functionScript: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) const result = a + b console.log(`${a} + ${b} = ${result}`) return result &lt; 0 ? 'negative' : 'positive' }, negative: 'echo It was negative.', positive: 'echo It was positive.' } }   $ jko functionScript 1 2 $ 1 + 2 = 3 $ It was positive. $ jko functionScript -2 1 $ -2 + 1 = -1 $ It was negative.   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript 1 2)  negative script is executed by jko when result is negative.positive script is executed by jko when result is positive or 0.    ","version":"Next","tagName":"h3"},{"title":"Chaining Function Script Calls‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#chaining-function-script-calls","content":" Chaining function script calls occurs when a function script returns the name of another function script.   export default { scripts: { functionScript: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) console.log(`${a} + ${b} = ${a + b}`) return 'show' }, show: function() { console.log(`at ${new Date()}`) return 'done' }, done: function() { console.log('Done!') } } }   Function Script functionScript calls Function Script show.Function Script show calls Function Script done.  This chaining can go on and on.  tip Chained function scripts runs faster than Chained commands.    ","version":"Next","tagName":"h2"},{"title":"When It Stops?‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#when-it-stops","content":" Chaining can continue indefinitely. It stops when:  the function script does not return a value or return a non-string value, orthe last script in the chain is a traditional script.  e.g.   export default { scripts: { functionScript: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) console.log(`${a} + ${b} = ${a + b}`) return 'show' }, show: function() { console.log(`at ${new Date()}`) return 'done' }, done: function() { console.log('Done!') } } }   Since the function script done returns no value, the chaining stops.  e.g.   export default { scripts: { functionScript: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) console.log(`${a} + ${b} = ${a + b}`) return 'show' }, show: function() { console.log(`at ${new Date()}`) return 'done' }, done: 'echo Done!', } }   Since done is a traditional script, the chaining stops.  note If the chain includes a traditional script, that script will always be the final one.    ","version":"Next","tagName":"h2"},{"title":"Arguments‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#arguments","content":" When chaining function scripts, the initial arguments are available to every function script in the chain.  e.g.   export default { scripts: { operation1: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) console.log(`${a} + ${b} = ${a + b}`) return 'operation2' }, operation2: function(param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) console.log(`${a} - ${b} = ${a - b}`) return 'operation3' }, operation3: function(param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) console.log(`${a} * ${b} = ${a * b}`) return 'done' }, done: 'echo Done!' } }   $ jko operation1 1.2 3.4 $ 1.2 + 3.4 = 4.6 $ 1.2 - 3.4 = -2.2 $ 1.2 * 3.4 = 4.08 $ Done!   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript 1 2)  warning Note that the argument-sharing mechanism for chained function scripts differs from the jko_arg_# values provided by the environment. While environment variables are shared among all descendant processes, the initial arguments are only available within the chain of function scripts    ","version":"Next","tagName":"h2"},{"title":"Passing values between Scripts‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#passing-values-between-scripts","content":" ","version":"Next","tagName":"h2"},{"title":"Using the Environment‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#using-the-environment","content":" If you need to pass values between scripts, you can set custom environment variables. These variables will be available to the next script invoked by the function script‚Äîwhether it‚Äôs a traditional script or another function script.  In a function script, use process.your_custom_env_var.In a traditional script, you can access them via $your_custom_env_var;  Example 1: Using Custom Environment Variables in a function script‚Äã   export default { scripts: { functionScript: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) // Set a custom environment variable, in this case called `jko_return_0`. process.env.jko_return_0 = `${a} + ${b} = ${a + b}` return 'show' }, show: function() { // Access custom environment variable console.log(process.env.jko_return_0) } } }   $ jko functionScript 1 2 $ 1 + 2 = 3   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript 1 2)  Example 2: Using Custom Environment Variables in a traditional script‚Äã   export default { scripts: { functionScript: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) // Set a custom environment variable, in this case called `jko_return_0`. process.env.jko_return_0 = `${a} + ${b} = ${a + b}` return 'show' }, show: 'echo $jko_return_0', // Access custom environment variable } }   $ jko functionScript 1 2 $ 1 + 2 = 3   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript 1 2)  warning Every value that is passed through an environment variable is automatically converted into a string.  ","version":"Next","tagName":"h3"},{"title":"Using Local Variables‚Äã","type":1,"pageTitle":"Chaining Function Scripts","url":"/usage/functions/chaining-function-script#using-local-variables","content":" When chaining function scripts from the same module, you can use local variables to share information between them.  Example: Using Local Variables in a function script‚Äã   let jkoReturn0 export default { scripts: { functionScript: function (param1, param2) { const a = parseFloat(param1) const b = parseFloat(param2) // Set local variable jkoReturn0 = `${a} + ${b} = ${a + b}` return 'show' }, show: function() { // Access local variable console.log(jkoReturn0) } } }   $ jko functionScript 1 2 $ 1 + 2 = 3   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript 1 2)  warning Since scripts are preprocessed, this approach doesn't work with traditional scripts. When the script is called, it reflects only the value that was initially set.   ","version":"Next","tagName":"h3"},{"title":"What about splitting scripts and dependencies","type":0,"sectionRef":"#","url":"/usage/split","content":"","keywords":"","version":"Next"},{"title":"Using json file‚Äã","type":1,"pageTitle":"What about splitting scripts and dependencies","url":"/usage/split#using-json-file","content":" If you choose to split definitions in a json file, the $extends and $installs declarative commands are required.  { &quot;scripts&quot;: { &quot;$extends&quot; : &quot;./another/path/scripts.js&quot;, &quot;$installs&quot; : &quot;./some/path/dependencies.js&quot;, } }    ","version":"Next","tagName":"h2"},{"title":"Environment","type":0,"sectionRef":"#","url":"/usage/environment","content":"","keywords":"environment .env file shared environment independent environment environment variables","version":"Next"},{"title":"Shared Environments‚Äã","type":1,"pageTitle":"Environment","url":"/usage/environment#shared-environments","content":" Chained processes share a common environment. As a result:  The environment variables holding the initial arguments are accessible in every script.Newly added environment variables are available to subsequent scripts after their definition.  Review the following image that demonstrates how the environment evolves during the chaining calls:    See that:  Initial arguments, jko_arg_0, jko_arg_1, etc. are accessible in every script, functionScript1, functionScript2 and functionScript3. Furthermore, they can be accessed as parameters these functions. jko_return_0 is accessible to functionScript2 and functionScript3.jko_return_1 is accessible to functionScript3.  For example:   export default { scripts: { functionScript1: function (param1, param2) { console.log('functionScript1:') console.log(param1 === process.env.jko_arg_0) console.log(param2 === process.env.jko_arg_1) process.env.jko_return_0 = `1. ${process.env.jko_arg_0}_${process.env.jko_arg_1}` return 'functionScript2' }, functionScript2: function (param1, param2) { console.log('functionScript2:') console.log(param1 === process.env.jko_arg_0) console.log(param2 === process.env.jko_arg_1) console.log(process.env.jko_return_0 === `1. ${process.env.jko_arg_0}_${process.env.jko_arg_1}`) process.env.jko_return_1 = `2. ${process.env.jko_arg_0}_${process.env.jko_arg_1}` return 'functionScript3' }, functionScript3: function (param1, param2) { console.log('functionScript3:') console.log(param1 === process.env.jko_arg_0) console.log(param2 === process.env.jko_arg_1) console.log(process.env.jko_return_0 === `1. ${process.env.jko_arg_0}_${process.env.jko_arg_1}`) console.log(process.env.jko_return_1 === `2. ${process.env.jko_arg_0}_${process.env.jko_arg_1}`) // End of the chaining } } }   When executed:  $ jko functionScript1 1 2 $ functionScript1: $ true $ true $ functionScript2: $ true $ true $ true $ functionScript3: $ true $ true $ true $ true $ jko functionScript2 1 2 $ functionScript2: $ true $ true $ false $ functionScript3: $ true $ true $ false $ true   (Actually, the output will be longer, but it has been simplified to emphasize functionality over presentation. To get the exact same output as in the example, use the following command: jko -l=e functionScript1 1 2)  ","version":"Next","tagName":"h2"},{"title":"Enhancing Process Environment‚Äã","type":1,"pageTitle":"Environment","url":"/usage/environment#enhancing-process-environment","content":" Use envFile in jko.js to specify the path of a .env file, which provides required environment variables to the new instance where the script will run.  jko.js:  export default { scripts: { yourScript1: &quot;someCommand&quot;, }, envFile: './path/to/.env', }   .env:  SOME_ENV_VAR=VALUE1   Additionally, the .env file can be specified using the CLI option --env-file:  $¬†jko¬†--env-file=./path/to/.env¬†yourScript¬†arg1¬†...¬†argN¬†  info command line option --env-file takes precedence over envFile.  ","version":"Next","tagName":"h2"},{"title":"Additional Environment Variables‚Äã","type":1,"pageTitle":"Environment","url":"/usage/environment#additional-environment-variables","content":" In addition to generating environment variables for each command-line argument,jko creates environment variables for every field exported by jko.js, package.json, or any configuration file specified via the --config-file option ‚Äî excluding scripts,dependencies and devDependencies.  These environment variables are generated with a jko_ prefix. Additionally, for compatibility reasons, variables prefixed with npm_package_ are also added.  For example, using the following jko.js:  export default { scripts: { yourScript1: &quot;someCommand&quot;, }, envFile: './path/to/.env', dependencies: { packageName1: &quot;1.0.0&quot; }, devDependencies: { devPackageName1: &quot;1.0.0&quot; }, packageManager: 'yarn', logLevel: 'warn', config: { data: ['A', 'B'] }, version: '1.2.3', name: 'theName' }   jko will generated the following variables:  jko_config_data_0, npm_package_config_data_0.jko_config_data_1, npm_package_config_data_1.jko_config_version, npm_package_version.jko_config_name, npm_package_name.  tip You can provide default jko_arg_ values using this mechanism‚Äîsimply define an arg field as an array: export default { scripts: { yourScript1: &quot;someCommand&quot;, }, arg: ['arg1', 'argN'] }     ","version":"Next","tagName":"h2"},{"title":"Summary‚Äã","type":1,"pageTitle":"Environment","url":"/usage/environment#summary","content":" tip Each jko execution runs in a new Independent Environment. This environment may belong to a Shared Environment or not, and it is a Shared Environment among its descendant processes.Chained function scripts run in a Shared Environment.Chained commands in traditional scripts run in a Shared Environment.jko introduces custom environment variables with a jko_ prefix (and, for compatibility, supports variables prefixed with npm_package_).Environment variables will be reachable in multiple ways. For function scripts, use process.env.NAME; for traditional scripts, use $NAME; and for other processes, the access method varies.   ","version":"Next","tagName":"h2"},{"title":"Run Scripts","type":0,"sectionRef":"#","url":"/usage/run-script","content":"","keywords":"run scripts package.json arguments environment CLI npm Alternative","version":"Next"},{"title":"Run a Script from jko.js‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#run-a-script-from-jkojs","content":" Given the following jko.js:  export default { scripts: { yourScript: &quot;someCommand&quot; } }   Execute:  $¬†jko¬†yourScript¬†  someCommand will be executed.    ","version":"Next","tagName":"h2"},{"title":"Run a Script from package.json‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#run-a-script-from-packagejson","content":" Given the following package.json:  { &quot;scripts&quot;: { &quot;yourScript&quot; : &quot;someCommand&quot; } }   Execute:  $¬†jko¬†yourScript¬†  someCommand will be executed.  info When jko is run, it will search for jko.js. If that file is not found, it will then look for package.json. If neither file is found, an error message will be displayed. $ jko ‚ó§ jko error - No configuration file found Please ensure that either jko.js or package.json exists in the working directory, or use --config-file to specify a custom one. ‚ó£  warning jko.js takes precedence over package.json.    ","version":"Next","tagName":"h2"},{"title":"Run a Script with Arguments‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#run-a-script-with-arguments","content":" Given the following package.json:  { &quot;scripts&quot;: { &quot;yourScript&quot; : &quot;someCommand $jko_arg_0 ... $jko_arg_N_1&quot; } }   Execute:  $¬†jko¬†yourScript¬†arg1¬†...¬†argN¬†  jko will execute someCommand with arg1 ... argN as arguments, where arg1 is the first argument and argN is the last argument.  info jko will create an environment variable for each argument passed, named jko_arg_#, where # starts at 0. For example, jko_arg_0 will contain the value of the first argument, and jko_arg_N_1 will contain the value of the last argument. arg1 saved in jko_arg_0 arg2 saved in jko_arg_1 arg3 saved in jko_arg_2 ...and so on.    ","version":"Next","tagName":"h2"},{"title":"Run Scripts from a File‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#run-scripts-from-a-file","content":" $¬†jko¬†--config-file=./path/to/config.js¬†yourScript¬†arg1¬†...¬†argN¬†  or  $¬†jko¬†-c=./path/to/config.js¬†yourScript¬†arg1¬†...¬†argN¬†  info File can be any .js, .mjs, .cjs or .json file.  warning The file path must start with /, ./, or ../.    ","version":"Next","tagName":"h2"},{"title":"Run Scripts from a Package‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#run-scripts-from-a-package","content":" $¬†jko¬†--config-file=somePackageName¬†yourScript¬†arg1¬†...¬†argN¬†  or  $¬†jko¬†-c=somePackageName¬†yourScript¬†arg1¬†...¬†argN¬†  warning The package must be available, i.e. it must be installed first.    ","version":"Next","tagName":"h2"},{"title":"Run Scripts in a Specified Environment‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#run-scripts-in-a-specified-environment","content":" $¬†jko¬†--env-file=./path/to/.env¬†yourScript¬†arg1¬†...¬†argN¬†  or  $¬†jko¬†-e=./path/to/.env¬†yourScript¬†arg1¬†...¬†argN¬†  or define the envFile value at jko.js (or package.json)  export default { scripts: { yourScript: &quot;someCommand&quot;, }, envFile: './path/to/.env' }   $¬†jko¬†yourScript¬†  warning command line option --env-file takes precedence over envFile.    ","version":"Next","tagName":"h2"},{"title":"What happens if the script is not found‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#what-happens-if-the-script-is-not-found","content":" Given the following jko.js:  export default { scripts: { yourScript: &quot;someCommand&quot;, } }   If you run yourScript1, jko will attempt to retrieve it. If it is not found, the jko will stop.  And it will display suggestions if available:  $ jko yourScript1 someText1 ‚ó§ jko error - yourScript1 not found, similar scripts are: yourScript: 'someCommand' ‚ó£  or if no suggestions are available, it will simply show an error:  $ jko yourScript1 ‚ó§ jko error - yourScript1 not found. ‚ó£  ","version":"Next","tagName":"h2"},{"title":"List available scripts‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#list-available-scripts","content":" To list available scripts, run jko without any arguments:  $ jko   info Even if no script is defined, at least one task is available: install.    ","version":"Next","tagName":"h3"},{"title":"Exit status‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#exit-status","content":" ","version":"Next","tagName":"h2"},{"title":"Error Code Reference‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#error-code-reference","content":" Code\tDescription0\tExecution completed successfully. No errors detected. 10\tError encountered with an imported file, such as missing or unreadable files. 11\tError with the script being executed: not found, incorrect script type, etc. 12\tInstallation error: dependencies not found or issues during installation process. 13\tInvalid command-line option: incorrect parameters, unrecognized log level, etc. ##\tWhen a script fails, jko returns its exit code, which can vary based on the script‚Äôs execution.  ","version":"Next","tagName":"h3"},{"title":"CLI output‚Äã","type":1,"pageTitle":"Run Scripts","url":"/usage/run-script#cli-output","content":" jko will display:  a green end label in the output when the script executes successfully‚Äîthat is, when the error code is zero:  $ jko yourScript ... ‚ó§ jko end - Successful execution of yourScript. ‚ó£  a orange end label in the output when the script executes successfully but warnings have been raised:  $ jko yourScript ... ‚ó§ jko end - Successful execution of yourScript. ‚ó£  a red end label in the output when the script executes but fails by returning a non-zero error code (##):  $ jko yourScript ... ‚ó§ jko end - yourScript: &quot; ... &quot; Failed. ‚ó£  a red error label in the output when a misconfiguration (10, 11, 12, 13) prevents a script from executing:  $ jko yourScript ... ‚ó§ jko error - yourScript not found. ‚ó£  tip Always verify the existence and validity of imported files (Error 10).Ensure the target script exists and follows correct formatting (Error 11). or use $disable declarative. Check dependency declarations to avoid installation failures (Error 12).Review command-line arguments carefully to prevent option-related errors (Error 13).If a script fails (##), investigate the returned exit code for further troubleshooting.Setting an appropriate logging level can help catch potential issues. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}